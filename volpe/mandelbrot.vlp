##### params #####
max_count := 100

total_rows := 30
total_cols := 65

start_re := -(2.1)
end_re := 0.5

start_im := 1.2
end_im := -(1.2)
##################

step_re := (end_re - start_re) / total_cols.0
step_im := (end_im - start_im) / total_rows.0


complex := (re, im) {
    complex := @
    add := (other) {
        # (a + bi) + (x + yi) = (a + x) + i(b + y)
        complex(re + other.re, im + other.im)
    }
    mult := (other) {
        # (a + bi)(x + yi) = ax + ayi + bxi + byii
        # = (ax - by) + i(ay + bx)
        complex(re * other.re - im * other.im, re * other.im + im * other.re)
    }
    {
        re: re,
        im: im,
        add: add,
        mult: mult,
        norm_squared: re * re + im * im
    }
}

# finds for how many repetitions z remains bounded
eval_c := (c) {
    (z, count) {
        z.norm_squared > 4.0 || count > max_count -> count
        @(z.mult(z).add(c), count + 1)
    } (complex(0.0, 0.0), 0)
}

get_symbol := (count_reached) {
    count_reached > max_count -> '0'
    count_reached > max_count / 5 -> 'x'
    count_reached > max_count / 10 -> '*'
    count_reached > max_count / 25 -> '.'
    ' '
}

# fake stdout
stdout := {
    text: ['\x00'; 2048],
    end: 0
}

print := (stdout, char) {
    # stop printing when we reached end
    stdout.end = |stdout.text| -> stdout

    stdout.text[stdout.end] := char
    stdout.end += 1
    stdout
}


mandelbrot := (image) {
    (row, image) {
        row >= total_rows -> image
        image := (col, image) {
            col >= total_cols -> image
            c := complex(start_re + step_re * col.0, start_im + step_im * row.0)
            count_reached := eval_c(c)
            symbol := get_symbol(count_reached)
            @(col + 1, print(image, symbol))
        } (0, image)
        # add newline at end of each row
        @(row + 1, print(image, '\n'))
    } (0, image)
}

mandelbrot(print(stdout, '\n')).text

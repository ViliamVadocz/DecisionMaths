# header imports
sqrt := $$math\sqrt

# local imports
ppm_image := $ppm_image\ppm_image
PI := $math\pi
sphere_intersect := $math\sphere_intersection
(
    norm: norm,
    normalize: normalize,
    dot: dot,
    cross: cross,
    rotation: rotation,
    apply: apply
) := $math\vec


##### PARAMS #####
WIDTH := 1920
HEIGHT := 1080

# horizonal FOV
H_FOV := PI / 2.0

CAM_POS := [0.0, 0.0, 100.0]
CAM_ORIENT := {
    [1.0, 0.0, 0.0],
    [0.0, 1.0, 0.0],
    [0.0, 0.0, 1.0]
}

# ground height (XY plane)
GROUND_LEVEL := 0.0

# point light
LIGHT_POS := [50.0, -100.0, 200.0]

# sphere
S_CENTRE := [100.0, 20.0, 50.0]
S_RADIUS := 50.0
##### ###### #####

# vertical FOV
V_FOV := (HEIGHT.0 / WIDTH.0) * H_FOV


render := (x, y) {
    h_angle := (WIDTH / 2 - x).0 * H_FOV / WIDTH.0
    v_angle := (HEIGHT / 2 - y).0 * V_FOV / HEIGHT.0

    direction := CAM_ORIENT._0
    direction := apply(rotation(CAM_ORIENT._2, -h_angle), direction)
    direction := apply(rotation(CAM_ORIENT._1, v_angle), direction)

    hit_sphere, collision_pos, _ := sphere_intersect(CAM_POS, direction, S_CENTRE, S_RADIUS)
    # we hit the sphere, check if can see light
    hit_sphere -> {
        to_light := LIGHT_POS - collision_pos
        in_shadow, _, _ := sphere_intersect(collision_pos, to_light, S_CENTRE, S_RADIUS)
        # cannot see light, but on sphere
        in_shadow -> {r: 100, g: 100, b: 100}
        # we are on the bright side of the sphere
        {r: 255, g: 255, b: 255}
    }

    # check if will collide with ground
    t := (GROUND_LEVEL - CAM_POS[2]) / direction[2]
    hit_ground := 0.0 >= t 
    hit_ground -> {
        collision_pos := CAM_POS + direction * [t; |direction|]
        to_light := LIGHT_POS - collision_pos
        in_shadow, _, _ := sphere_intersect(collision_pos, to_light, S_CENTRE, S_RADIUS)
        # in the shadow of the sphere
        in_shadow -> {r: 0, g: 0, b: 100}
        # open ground
        {r: 0, g: 0, b: 255}
    }

    # otherwise black
    r: 0, g: 0, b: 0
}

ppm_image("sphere.ppm\0", WIDTH, HEIGHT, render)
